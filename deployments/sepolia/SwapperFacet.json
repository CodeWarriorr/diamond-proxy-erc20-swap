{
  "address": "0x58D42d3781e5E2c0fbd9e200170406bf7391cC09",
  "abi": [
    {
      "inputs": [],
      "name": "ContractIsPaused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EthAmountIsZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrancyGuard__ReentrantCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TokenPoolIsMissing",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "wallet",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Swapped",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "checkPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minAmount",
          "type": "uint256"
        }
      ],
      "name": "swapEtherToToken",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x688b48196099ce3408314960021e38d663af2b35779707237de44a73b261bf8f",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xEB0680e8fEF19f5B6490a083d5b59f6F04930B5B",
    "contractAddress": null,
    "transactionIndex": 43,
    "gasUsed": "484009",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xba8bee6ce66fbbde56b2441eaa3794be611f49f67e96ce0ac827489d9e0b1ec2",
    "transactionHash": "0x688b48196099ce3408314960021e38d663af2b35779707237de44a73b261bf8f",
    "logs": [],
    "blockNumber": 6092048,
    "cumulativeGasUsed": "8832928",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "01a6643178f9a915bf0c9a2bac41d78c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.26+commit.8a97fa7a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ContractIsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthAmountIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuard__ReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenPoolIsMissing\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"swapEtherToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"codewarriorr@pm.me\",\"kind\":\"dev\",\"methods\":{\"checkPool(address)\":{\"params\":{\"token\":\"address of the token to check pool for\"}},\"swapEtherToToken(address,uint256)\":{\"params\":{\"minAmount\":\"minimum amount of tokens to receive\",\"token\":\"token to swap to\"}}},\"title\":\"SwapperFacet\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"checkPool(address)\":{\"notice\":\"Check if a pool exists for the given token\"},\"swapEtherToToken(address,uint256)\":{\"notice\":\"Swap Ether to ERC-20 token through Uniswap V3 using Universal Router \"}},\"notice\":\"Swap Ether to ERC-20 tokens using Uniswap V3 through Universal Router\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/SwapperFacet.sol\":\"SwapperFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb69597a63b202e28401128bed6a6d259e8730191274471af7303eafb247881a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"@solidstate/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport { IERC20Internal } from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice query the allowance granted from given holder to given spender\\n     * @param holder approver of allowance\\n     * @param spender recipient of allowance\\n     * @return token allowance\\n     */\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice grant approval to spender to spend tokens\\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient on behalf of given holder\\n     * @param holder holder of tokens prior to transfer\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4f78e70ef7d78d7bc76f1923877b250d7d779634d867ac21e22a4d994681645a\",\"license\":\"MIT\"},\"@solidstate/contracts/interfaces/IERC20Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\",\"keccak256\":\"0x752efc249e30423f5d07b89ef03bd886802bbe0b0ea49a7aa359731fe18e324d\",\"license\":\"MIT\"},\"@solidstate/contracts/security/pausable/PausableStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nlibrary PausableStorage {\\n    struct Layout {\\n        bool paused;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Pausable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf1e867e5baa13605b275dcb80f3c7d83195dde57d0272dcc5a000d62f04d3a9b\",\"license\":\"MIT\"},\"@solidstate/contracts/security/reentrancy_guard/IReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\ninterface IReentrancyGuard {\\n    error ReentrancyGuard__ReentrantCall();\\n}\\n\",\"keccak256\":\"0xb597334789598dd2e1a964b848755e7764c99dcee3de44157ab37432086bd479\",\"license\":\"MIT\"},\"@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport { IReentrancyGuard } from './IReentrancyGuard.sol';\\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\\n\\n/**\\n * @title Utility contract for preventing reentrancy attacks\\n */\\nabstract contract ReentrancyGuard is IReentrancyGuard {\\n    uint256 internal constant REENTRANCY_STATUS_LOCKED = 2;\\n    uint256 internal constant REENTRANCY_STATUS_UNLOCKED = 1;\\n\\n    modifier nonReentrant() virtual {\\n        if (_isReentrancyGuardLocked()) revert ReentrancyGuard__ReentrantCall();\\n        _lockReentrancyGuard();\\n        _;\\n        _unlockReentrancyGuard();\\n    }\\n\\n    /**\\n     * @notice returns true if the reentrancy guard is locked, false otherwise\\n     */\\n    function _isReentrancyGuardLocked() internal view virtual returns (bool) {\\n        return\\n            ReentrancyGuardStorage.layout().status == REENTRANCY_STATUS_LOCKED;\\n    }\\n\\n    /**\\n     * @notice lock functions that use the nonReentrant modifier\\n     */\\n    function _lockReentrancyGuard() internal virtual {\\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_LOCKED;\\n    }\\n\\n    /**\\n     * @notice unlock functions that use the nonReentrant modifier\\n     */\\n    function _unlockReentrancyGuard() internal virtual {\\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_UNLOCKED;\\n    }\\n}\\n\",\"keccak256\":\"0x69c4a7be74b50d2d2ee302271374e8c6707ac77cdc68d9c8799f49a3e84aa5d4\",\"license\":\"MIT\"},\"@solidstate/contracts/security/reentrancy_guard/ReentrancyGuardStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nlibrary ReentrancyGuardStorage {\\n    struct Layout {\\n        uint256 status;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4250d32af866ae3a6f5d8566348d640090e92028cb5336339853bbffccc5f14b\",\"license\":\"MIT\"},\"@uniswap/universal-router/contracts/interfaces/IRewardsCollector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.15;\\n\\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\\n\\n/// @title LooksRare Rewards Collector\\n/// @notice Implements a permissionless call to fetch LooksRare rewards earned by Universal Router users\\n/// and transfers them to an external rewards distributor contract\\ninterface IRewardsCollector {\\n    /// @notice Fetches users' LooksRare rewards and sends them to the distributor contract\\n    /// @param looksRareClaim The data required by LooksRare to claim reward tokens\\n    function collectRewards(bytes calldata looksRareClaim) external;\\n}\\n\",\"keccak256\":\"0x394a3c99a6ef18c0de171e85f8c6352eb3f6f1c5165fe9a2fdc4db181dd407b2\",\"license\":\"GPL-3.0-or-later\"},\"@uniswap/universal-router/contracts/interfaces/IUniversalRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport {IERC1155Receiver} from '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol';\\nimport {IRewardsCollector} from './IRewardsCollector.sol';\\n\\ninterface IUniversalRouter is IRewardsCollector, IERC721Receiver, IERC1155Receiver {\\n    /// @notice Thrown when a required command has failed\\n    error ExecutionFailed(uint256 commandIndex, bytes message);\\n\\n    /// @notice Thrown when attempting to send ETH directly to the contract\\n    error ETHNotAccepted();\\n\\n    /// @notice Thrown when executing commands with an expired deadline\\n    error TransactionDeadlinePassed();\\n\\n    /// @notice Thrown when attempting to execute commands and an incorrect number of inputs are provided\\n    error LengthMismatch();\\n\\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\\n    /// @param commands A set of concatenated commands, each 1 byte in length\\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\\n    /// @param deadline The deadline by which the transaction must be executed\\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;\\n}\\n\",\"keccak256\":\"0x417bd7e38a2373a7560004b38aab6987b4e0c655574d18c879a562dcff275e00\",\"license\":\"GPL-3.0-or-later\"},\"@uniswap/universal-router/contracts/libraries/Commands.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\n/// @title Commands\\n/// @notice Command Flags used to decode commands\\nlibrary Commands {\\n    // Masks to extract certain bits of commands\\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\\n\\n    // Command Types. Maximum supported command at this moment is 0x3f.\\n\\n    // Command Types where value<0x08, executed in the first nested-if block\\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\\n    uint256 constant SWEEP = 0x04;\\n    uint256 constant TRANSFER = 0x05;\\n    uint256 constant PAY_PORTION = 0x06;\\n    // COMMAND_PLACEHOLDER = 0x07;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant FIRST_IF_BOUNDARY = 0x08;\\n\\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\\n    uint256 constant PERMIT2_PERMIT = 0x0a;\\n    uint256 constant WRAP_ETH = 0x0b;\\n    uint256 constant UNWRAP_WETH = 0x0c;\\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\\n    // COMMAND_PLACEHOLDER = 0x0f;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant SECOND_IF_BOUNDARY = 0x10;\\n\\n    // Command Types where 0x10<=value<0x18, executed in the third nested-if block\\n    uint256 constant SEAPORT_V1_5 = 0x10;\\n    uint256 constant LOOKS_RARE_V2 = 0x11;\\n    uint256 constant NFTX = 0x12;\\n    uint256 constant CRYPTOPUNKS = 0x13;\\n    // 0x14;\\n    uint256 constant OWNER_CHECK_721 = 0x15;\\n    uint256 constant OWNER_CHECK_1155 = 0x16;\\n    uint256 constant SWEEP_ERC721 = 0x17;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant THIRD_IF_BOUNDARY = 0x18;\\n\\n    // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\\n    uint256 constant X2Y2_721 = 0x18;\\n    uint256 constant SUDOSWAP = 0x19;\\n    uint256 constant NFT20 = 0x1a;\\n    uint256 constant X2Y2_1155 = 0x1b;\\n    uint256 constant FOUNDATION = 0x1c;\\n    uint256 constant SWEEP_ERC1155 = 0x1d;\\n    uint256 constant ELEMENT_MARKET = 0x1e;\\n    // COMMAND_PLACEHOLDER = 0x1f;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant FOURTH_IF_BOUNDARY = 0x20;\\n\\n    // Command Types where 0x20<=value\\n    uint256 constant SEAPORT_V1_4 = 0x20;\\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\\n    uint256 constant APPROVE_ERC20 = 0x22;\\n    // COMMAND_PLACEHOLDER for 0x23 to 0x3f (all unused)\\n}\\n\",\"keccak256\":\"0x7495192865b4cdd91d2469183c4550ac621669f77a0c8952a53d3c287410f64f\",\"license\":\"GPL-3.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\",\"keccak256\":\"0xcc3d0c93fc9ac0febbe09f941b465b57f750bcf3b48432da0b97dc289cfdc489\",\"license\":\"GPL-2.0-or-later\"},\"contracts/facets/SwapperFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.26;\\n\\nimport { WithStorage, WithModifiers } from \\\"../libraries/LibStorage.sol\\\";\\nimport { ERC20Swapper } from \\\"../interfaces/ERC20Swapper.sol\\\";\\nimport { IUniswapV3Factory } from \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\\\";\\nimport { IUniversalRouter } from \\\"@uniswap/universal-router/contracts/interfaces/IUniversalRouter.sol\\\";\\nimport { Commands } from \\\"@uniswap/universal-router/contracts/libraries/Commands.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ReentrancyGuard } from \\\"@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol\\\";\\nimport { CommonErrors } from \\\"../interfaces/CommonErrors.sol\\\";\\n\\n/**\\n * @title SwapperFacet\\n * @author codewarriorr@pm.me\\n * @notice Swap Ether to ERC-20 tokens using Uniswap V3 through Universal Router\\n */\\ncontract SwapperFacet is WithStorage, WithModifiers, CommonErrors, ReentrancyGuard, ERC20Swapper {\\n    IUniswapV3Factory private constant uniswapFactory = IUniswapV3Factory(0x0227628f3F023bb0B980b67D528571c95c6DaC1c); // uniswap v3 factory (sepolia)\\n    IUniversalRouter private constant universalRouter = IUniversalRouter(0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD); // uniswap universal router (sepolia)\\n    address private constant WETH = 0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14; // wrapped eth (sepolia)\\n\\n    uint24 private constant fee = 3000;\\n\\n    event Swapped(address indexed wallet, address indexed token, uint amount);\\n\\n    error EthAmountIsZero();\\n    error TokenPoolIsMissing();\\n\\n    /**\\n     * @notice Check if a pool exists for the given token\\n     * @param token address of the token to check pool for\\n     */\\n    function checkPool(address token) public view returns (address) {\\n        return uniswapFactory.getPool(WETH, token, fee);\\n    }\\n\\n    /**\\n     * @notice Swap Ether to ERC-20 token through Uniswap V3 using Universal Router\\n     * \\n     * @param token token to swap to\\n     * @param minAmount minimum amount of tokens to receive\\n     */\\n    function swapEtherToToken(address token, uint minAmount) public payable isNotPaused nonReentrant returns (uint) {\\n        require(msg.value > 0, EthAmountIsZero());\\n\\n        uint256 deadline = block.timestamp + 15;\\n\\n        address pool = uniswapFactory.getPool(WETH, token, fee);\\n        require(pool != address(0), TokenPoolIsMissing());\\n\\n        uint balanceBefore = IERC20(token).balanceOf(msg.sender);\\n\\n        IERC20(WETH).approve(address(universalRouter), msg.value);\\n\\n        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.WRAP_ETH)), bytes1(uint8(Commands.V3_SWAP_EXACT_IN)));\\n\\n        bytes[] memory inputs = new bytes[](2);\\n        inputs[0] = abi.encode(address(universalRouter), msg.value);\\n        inputs[1] = abi.encode(msg.sender, msg.value, minAmount, abi.encodePacked(WETH, fee, token), false);\\n        universalRouter.execute{ value: msg.value }(commands, inputs, deadline);\\n\\n        uint balanceAfter = IERC20(token).balanceOf(msg.sender);\\n        uint swappedAmount = balanceAfter - balanceBefore;\\n\\n        emit Swapped(msg.sender, token, swappedAmount);\\n\\n        return swappedAmount;\\n    }\\n}\\n\",\"keccak256\":\"0xa2f67110a4944f47c6910f27e2170af38700e3cc80d343cf8aa915d6d45279ef\",\"license\":\"MIT\"},\"contracts/interfaces/CommonErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.26;\\n\\n/**\\n * @title CommonErrors\\n * @author codewarriorr@pm.me\\n * @notice Errors to be used in multiple facets and thus to be attached to ABI\\n */\\ninterface CommonErrors {\\n  error ContractIsPaused();\\n}\",\"keccak256\":\"0x389711b62f2c0fce15dda71243f37e045310e23378862e4734acde63e729643e\",\"license\":\"MIT\"},\"contracts/interfaces/ERC20Swapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.26;\\n\\ninterface ERC20Swapper {\\n    /// @dev swaps the `msg.value` Ether to at least `minAmount` of tokens in `address`, or reverts\\n    /// @param token The address of ERC-20 token to swap\\n    /// @param minAmount The minimum amount of tokens transferred to msg.sender\\n    /// @return The actual amount of transferred tokens\\n    function swapEtherToToken(address token, uint minAmount) external payable returns (uint);\\n}\",\"keccak256\":\"0xb16a27feaeb4c3e03bdb9874feaf2472a23874cb1aaf8bae5eb7f3b4db666eca\",\"license\":\"MIT\"},\"contracts/libraries/LibStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.26;\\n\\nimport { LibDiamond } from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\nimport { IERC20 } from \\\"@solidstate/contracts/interfaces/IERC20.sol\\\";\\nimport { PausableStorage } from \\\"@solidstate/contracts/security/pausable/PausableStorage.sol\\\";\\nimport { CommonErrors } from \\\"../interfaces/CommonErrors.sol\\\";\\n\\nstruct AppStorage {\\n    bool isInitialized;\\n}\\n\\ncontract WithModifiers {\\n    modifier isOwner() {\\n        require(LibDiamond.contractOwner() == msg.sender, \\\"Must be contract owner\\\");\\n        _;\\n    }\\n\\n    modifier isNotPaused() {\\n        if (PausableStorage.layout().paused) {\\n            revert CommonErrors.ContractIsPaused();\\n        }\\n        _;\\n    }\\n}\\n\\ncontract WithStorage {\\n    bytes32 private constant APP_STORAGE_SLOT = keccak256(\\\"storage.slot.app\\\");\\n\\n    function a() internal pure returns (AppStorage storage appStorage) {\\n        bytes32 slot = APP_STORAGE_SLOT;\\n        assembly {\\n            appStorage.slot := slot\\n        }\\n    }\\n\\n    function ds() internal pure returns (LibDiamond.DiamondStorage storage) {\\n        return LibDiamond.diamondStorage();\\n    }\\n}\\n\",\"keccak256\":\"0xf0be11327e6f7635352c47ea867800f3ebdc3a502a9db01bcfd1042771331335\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x2205345e83eb86f5281f159a9215a096cb6d404782619f9b8e9d7a4a46c32a37\",\"license\":\"MIT\"},\"solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608080604052346015576107c4908161001b8239f35b600080fdfe608080604052600436101561001357600080fd5b600090813560e01c90816330b9d2a7146105ec5750637a2a04561461003757600080fd5b60403660031901126105e95761004b6106ad565b60ff7f68721c0bbf2c02a4d65000340d1370666be06a630022208d4baa9bd7a4b6fea854166105da5760027f09acf4e54214992e70883cf7dcd6957ff2c71cd9e14df4bec4383bc0d11607dc54146105cb5760027f09acf4e54214992e70883cf7dcd6957ff2c71cd9e14df4bec4383bc0d11607dc5534156105bc57600f420180421161044557604051630b4c774160e11b815273fff9976782d46cc05630d1f6ebab18b2324d6b1460048201526001600160a01b03831660248201819052610bb860448301529190602081606481730227628f3f023bb0b980b67d528571c95c6dac1c5afa90811561057357859161058d575b506001600160a01b03161561057e576040516370a0823160e01b815233600482015292602084602481865afa93841561057357859461053b575b5060405163095ea7b360e01b8152733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad60048201523460248201526020816044818973fff9976782d46cc05630d1f6ebab18b2324d6b145af18015610530576104f8575b50604051600b60f81b60208201526021810186905260028152916101f56022846106c3565b6060926040519261020685856106c3565b60028452601f198501885b8181106104e857505060408051733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad602082015234818301529081526102eb916102ff916102536060826106c3565b61025c8761071a565b526102668661071a565b506040517ffff9976782d46cc05630d1f6ebab18b2324d6b14000000000000000000000000602082015261017760eb1b603482015290871b6bffffffffffffffffffffffff19166037820152602b81526102c1604b826106c3565b6040519283913360208401523460408401526024358984015260a0608084015260c083019061074d565b8a60a083015203601f1981018352826106c3565b6103088461073d565b526103128361073d565b50733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad3b156104e45792869192610354604051958693630d64d59360e21b85526004850152606484019061074d565b93600319838603016024840152815180865260208601956020808360051b83010194019686915b8383106104b15750505050829394506044830152038134733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad5af180156104925761049d575b506040516370a0823160e01b815233600482015291602083602481855afa928315610492578493610459575b50820391821161044557602092506040518281527f2e7f8a64aa3240292c0adfa332e1e8945dd31589fcb0bce2721fa21c69b1390f843392a360017f09acf4e54214992e70883cf7dcd6957ff2c71cd9e14df4bec4383bc0d11607dc55604051908152f35b634e487b7160e01b83526011600452602483fd5b9092506020813d60201161048a575b81610475602093836106c3565b81010312610485575191386103e0565b600080fd5b3d9150610468565b6040513d86823e3d90fd5b836104aa919492946106c3565b91386103b4565b929550929550926020806104d1600193601f198682030187528a5161074d565b9801930193018a9592969388959261037b565b8680fd5b8087602080938901015201610211565b6020813d602011610528575b81610511602093836106c3565b81010312610524575180151581146101d0575b8580fd5b3d9150610504565b6040513d88823e3d90fd5b9093506020813d60201161056b575b81610557602093836106c3565b8101031261056757519238610179565b8480fd5b3d915061054a565b6040513d87823e3d90fd5b63162c895f60e21b8452600484fd5b6105af915060203d6020116105b5575b6105a781836106c3565b8101906106fb565b3861013f565b503d61059d565b63323940cd60e21b8252600482fd5b635db5c7cd60e11b8252600482fd5b6306d39fcd60e41b8252600482fd5b80fd5b9050346106a95760203660031901126106a9576106076106ad565b630b4c774160e11b825273fff9976782d46cc05630d1f6ebab18b2324d6b1460048301526001600160a01b03166024820152610bb86044820152602081606481730227628f3f023bb0b980b67d528571c95c6dac1c5afa90811561069e5760209291610681575b506040516001600160a01b039091168152f35b6106989150823d84116105b5576105a781836106c3565b3861066e565b6040513d84823e3d90fd5b5080fd5b600435906001600160a01b038216820361048557565b90601f8019910116810190811067ffffffffffffffff8211176106e557604052565b634e487b7160e01b600052604160045260246000fd5b9081602091031261048557516001600160a01b03811681036104855790565b8051156107275760200190565b634e487b7160e01b600052603260045260246000fd5b8051600110156107275760400190565b919082519283825260005b848110610779575050826000602080949584010152601f8019910116010190565b8060208092840101518282860101520161075856fea2646970667358221220ec13f2d408a5449b89b81d46164b8168fe2f323ee1a311151f8265b7214b3f0f64736f6c634300081a0033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b600090813560e01c90816330b9d2a7146105ec5750637a2a04561461003757600080fd5b60403660031901126105e95761004b6106ad565b60ff7f68721c0bbf2c02a4d65000340d1370666be06a630022208d4baa9bd7a4b6fea854166105da5760027f09acf4e54214992e70883cf7dcd6957ff2c71cd9e14df4bec4383bc0d11607dc54146105cb5760027f09acf4e54214992e70883cf7dcd6957ff2c71cd9e14df4bec4383bc0d11607dc5534156105bc57600f420180421161044557604051630b4c774160e11b815273fff9976782d46cc05630d1f6ebab18b2324d6b1460048201526001600160a01b03831660248201819052610bb860448301529190602081606481730227628f3f023bb0b980b67d528571c95c6dac1c5afa90811561057357859161058d575b506001600160a01b03161561057e576040516370a0823160e01b815233600482015292602084602481865afa93841561057357859461053b575b5060405163095ea7b360e01b8152733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad60048201523460248201526020816044818973fff9976782d46cc05630d1f6ebab18b2324d6b145af18015610530576104f8575b50604051600b60f81b60208201526021810186905260028152916101f56022846106c3565b6060926040519261020685856106c3565b60028452601f198501885b8181106104e857505060408051733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad602082015234818301529081526102eb916102ff916102536060826106c3565b61025c8761071a565b526102668661071a565b506040517ffff9976782d46cc05630d1f6ebab18b2324d6b14000000000000000000000000602082015261017760eb1b603482015290871b6bffffffffffffffffffffffff19166037820152602b81526102c1604b826106c3565b6040519283913360208401523460408401526024358984015260a0608084015260c083019061074d565b8a60a083015203601f1981018352826106c3565b6103088461073d565b526103128361073d565b50733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad3b156104e45792869192610354604051958693630d64d59360e21b85526004850152606484019061074d565b93600319838603016024840152815180865260208601956020808360051b83010194019686915b8383106104b15750505050829394506044830152038134733fc91a3afd70395cd496c647d5a6cc9d4b2b7fad5af180156104925761049d575b506040516370a0823160e01b815233600482015291602083602481855afa928315610492578493610459575b50820391821161044557602092506040518281527f2e7f8a64aa3240292c0adfa332e1e8945dd31589fcb0bce2721fa21c69b1390f843392a360017f09acf4e54214992e70883cf7dcd6957ff2c71cd9e14df4bec4383bc0d11607dc55604051908152f35b634e487b7160e01b83526011600452602483fd5b9092506020813d60201161048a575b81610475602093836106c3565b81010312610485575191386103e0565b600080fd5b3d9150610468565b6040513d86823e3d90fd5b836104aa919492946106c3565b91386103b4565b929550929550926020806104d1600193601f198682030187528a5161074d565b9801930193018a9592969388959261037b565b8680fd5b8087602080938901015201610211565b6020813d602011610528575b81610511602093836106c3565b81010312610524575180151581146101d0575b8580fd5b3d9150610504565b6040513d88823e3d90fd5b9093506020813d60201161056b575b81610557602093836106c3565b8101031261056757519238610179565b8480fd5b3d915061054a565b6040513d87823e3d90fd5b63162c895f60e21b8452600484fd5b6105af915060203d6020116105b5575b6105a781836106c3565b8101906106fb565b3861013f565b503d61059d565b63323940cd60e21b8252600482fd5b635db5c7cd60e11b8252600482fd5b6306d39fcd60e41b8252600482fd5b80fd5b9050346106a95760203660031901126106a9576106076106ad565b630b4c774160e11b825273fff9976782d46cc05630d1f6ebab18b2324d6b1460048301526001600160a01b03166024820152610bb86044820152602081606481730227628f3f023bb0b980b67d528571c95c6dac1c5afa90811561069e5760209291610681575b506040516001600160a01b039091168152f35b6106989150823d84116105b5576105a781836106c3565b3861066e565b6040513d84823e3d90fd5b5080fd5b600435906001600160a01b038216820361048557565b90601f8019910116810190811067ffffffffffffffff8211176106e557604052565b634e487b7160e01b600052604160045260246000fd5b9081602091031261048557516001600160a01b03811681036104855790565b8051156107275760200190565b634e487b7160e01b600052603260045260246000fd5b8051600110156107275760400190565b919082519283825260005b848110610779575050826000602080949584010152601f8019910116010190565b8060208092840101518282860101520161075856fea2646970667358221220ec13f2d408a5449b89b81d46164b8168fe2f323ee1a311151f8265b7214b3f0f64736f6c634300081a0033",
  "devdoc": {
    "author": "codewarriorr@pm.me",
    "kind": "dev",
    "methods": {
      "checkPool(address)": {
        "params": {
          "token": "address of the token to check pool for"
        }
      },
      "swapEtherToToken(address,uint256)": {
        "params": {
          "minAmount": "minimum amount of tokens to receive",
          "token": "token to swap to"
        }
      }
    },
    "title": "SwapperFacet",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "checkPool(address)": {
        "notice": "Check if a pool exists for the given token"
      },
      "swapEtherToToken(address,uint256)": {
        "notice": "Swap Ether to ERC-20 token through Uniswap V3 using Universal Router "
      }
    },
    "notice": "Swap Ether to ERC-20 tokens using Uniswap V3 through Universal Router",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}